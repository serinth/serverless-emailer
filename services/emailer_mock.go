// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package services

import (
	"github.com/serinth/serverless-emailer/api"
	"sync"
)

var (
	lockEmailerMockBCC       sync.RWMutex
	lockEmailerMockCC        sync.RWMutex
	lockEmailerMockContent   sync.RWMutex
	lockEmailerMockFrom      sync.RWMutex
	lockEmailerMockSend      sync.RWMutex
	lockEmailerMockSetAPIKey sync.RWMutex
	lockEmailerMockSetUrl    sync.RWMutex
	lockEmailerMockSubject   sync.RWMutex
	lockEmailerMockTo        sync.RWMutex
)

// EmailerMock is a mock implementation of Emailer.
//
//     func TestSomethingThatUsesEmailer(t *testing.T) {
//
//         // make and configure a mocked Emailer
//         mockedEmailer := &EmailerMock{
//             BCCFunc: func(addresses []*api.Address) Emailer {
// 	               panic("TODO: mock out the BCC method")
//             },
//             CCFunc: func(addresses []*api.Address) Emailer {
// 	               panic("TODO: mock out the CC method")
//             },
//             ContentFunc: func(content *string) Emailer {
// 	               panic("TODO: mock out the Content method")
//             },
//             FromFunc: func(address *api.Address) Emailer {
// 	               panic("TODO: mock out the From method")
//             },
//             SendFunc: func() error {
// 	               panic("TODO: mock out the Send method")
//             },
//             SetAPIKeyFunc: func(key string) Emailer {
// 	               panic("TODO: mock out the SetAPIKey method")
//             },
//             SetUrlFunc: func(url string) Emailer {
// 	               panic("TODO: mock out the SetUrl method")
//             },
//             SubjectFunc: func(subject *string) Emailer {
// 	               panic("TODO: mock out the Subject method")
//             },
//             ToFunc: func(addresses []*api.Address) Emailer {
// 	               panic("TODO: mock out the To method")
//             },
//         }
//
//         // TODO: use mockedEmailer in code that requires Emailer
//         //       and then make assertions.
//
//     }
type EmailerMock struct {
	// BCCFunc mocks the BCC method.
	BCCFunc func(addresses []*api.Address) Emailer

	// CCFunc mocks the CC method.
	CCFunc func(addresses []*api.Address) Emailer

	// ContentFunc mocks the Content method.
	ContentFunc func(content *string) Emailer

	// FromFunc mocks the From method.
	FromFunc func(address *api.Address) Emailer

	// SendFunc mocks the Send method.
	SendFunc func() error

	// SetAPIKeyFunc mocks the SetAPIKey method.
	SetAPIKeyFunc func(key string) Emailer

	// SetUrlFunc mocks the SetUrl method.
	SetUrlFunc func(url string) Emailer

	// SubjectFunc mocks the Subject method.
	SubjectFunc func(subject *string) Emailer

	// ToFunc mocks the To method.
	ToFunc func(addresses []*api.Address) Emailer

	// calls tracks calls to the methods.
	calls struct {
		// BCC holds details about calls to the BCC method.
		BCC []struct {
			// Addresses is the addresses argument value.
			Addresses []*api.Address
		}
		// CC holds details about calls to the CC method.
		CC []struct {
			// Addresses is the addresses argument value.
			Addresses []*api.Address
		}
		// Content holds details about calls to the Content method.
		Content []struct {
			// Content is the content argument value.
			Content *string
		}
		// From holds details about calls to the From method.
		From []struct {
			// Address is the address argument value.
			Address *api.Address
		}
		// Send holds details about calls to the Send method.
		Send []struct {
		}
		// SetAPIKey holds details about calls to the SetAPIKey method.
		SetAPIKey []struct {
			// Key is the key argument value.
			Key string
		}
		// SetUrl holds details about calls to the SetUrl method.
		SetUrl []struct {
			// URL is the url argument value.
			URL string
		}
		// Subject holds details about calls to the Subject method.
		Subject []struct {
			// Subject is the subject argument value.
			Subject *string
		}
		// To holds details about calls to the To method.
		To []struct {
			// Addresses is the addresses argument value.
			Addresses []*api.Address
		}
	}
}

// BCC calls BCCFunc.
func (mock *EmailerMock) BCC(addresses []*api.Address) Emailer {
	if mock.BCCFunc == nil {
		panic("moq: EmailerMock.BCCFunc is nil but Emailer.BCC was just called")
	}
	callInfo := struct {
		Addresses []*api.Address
	}{
		Addresses: addresses,
	}
	lockEmailerMockBCC.Lock()
	mock.calls.BCC = append(mock.calls.BCC, callInfo)
	lockEmailerMockBCC.Unlock()
	return mock.BCCFunc(addresses)
}

// BCCCalls gets all the calls that were made to BCC.
// Check the length with:
//     len(mockedEmailer.BCCCalls())
func (mock *EmailerMock) BCCCalls() []struct {
	Addresses []*api.Address
} {
	var calls []struct {
		Addresses []*api.Address
	}
	lockEmailerMockBCC.RLock()
	calls = mock.calls.BCC
	lockEmailerMockBCC.RUnlock()
	return calls
}

// CC calls CCFunc.
func (mock *EmailerMock) CC(addresses []*api.Address) Emailer {
	if mock.CCFunc == nil {
		panic("moq: EmailerMock.CCFunc is nil but Emailer.CC was just called")
	}
	callInfo := struct {
		Addresses []*api.Address
	}{
		Addresses: addresses,
	}
	lockEmailerMockCC.Lock()
	mock.calls.CC = append(mock.calls.CC, callInfo)
	lockEmailerMockCC.Unlock()
	return mock.CCFunc(addresses)
}

// CCCalls gets all the calls that were made to CC.
// Check the length with:
//     len(mockedEmailer.CCCalls())
func (mock *EmailerMock) CCCalls() []struct {
	Addresses []*api.Address
} {
	var calls []struct {
		Addresses []*api.Address
	}
	lockEmailerMockCC.RLock()
	calls = mock.calls.CC
	lockEmailerMockCC.RUnlock()
	return calls
}

// Content calls ContentFunc.
func (mock *EmailerMock) Content(content *string) Emailer {
	if mock.ContentFunc == nil {
		panic("moq: EmailerMock.ContentFunc is nil but Emailer.Content was just called")
	}
	callInfo := struct {
		Content *string
	}{
		Content: content,
	}
	lockEmailerMockContent.Lock()
	mock.calls.Content = append(mock.calls.Content, callInfo)
	lockEmailerMockContent.Unlock()
	return mock.ContentFunc(content)
}

// ContentCalls gets all the calls that were made to Content.
// Check the length with:
//     len(mockedEmailer.ContentCalls())
func (mock *EmailerMock) ContentCalls() []struct {
	Content *string
} {
	var calls []struct {
		Content *string
	}
	lockEmailerMockContent.RLock()
	calls = mock.calls.Content
	lockEmailerMockContent.RUnlock()
	return calls
}

// From calls FromFunc.
func (mock *EmailerMock) From(address *api.Address) Emailer {
	if mock.FromFunc == nil {
		panic("moq: EmailerMock.FromFunc is nil but Emailer.From was just called")
	}
	callInfo := struct {
		Address *api.Address
	}{
		Address: address,
	}
	lockEmailerMockFrom.Lock()
	mock.calls.From = append(mock.calls.From, callInfo)
	lockEmailerMockFrom.Unlock()
	return mock.FromFunc(address)
}

// FromCalls gets all the calls that were made to From.
// Check the length with:
//     len(mockedEmailer.FromCalls())
func (mock *EmailerMock) FromCalls() []struct {
	Address *api.Address
} {
	var calls []struct {
		Address *api.Address
	}
	lockEmailerMockFrom.RLock()
	calls = mock.calls.From
	lockEmailerMockFrom.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *EmailerMock) Send() error {
	if mock.SendFunc == nil {
		panic("moq: EmailerMock.SendFunc is nil but Emailer.Send was just called")
	}
	callInfo := struct {
	}{}
	lockEmailerMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockEmailerMockSend.Unlock()
	return mock.SendFunc()
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedEmailer.SendCalls())
func (mock *EmailerMock) SendCalls() []struct {
} {
	var calls []struct {
	}
	lockEmailerMockSend.RLock()
	calls = mock.calls.Send
	lockEmailerMockSend.RUnlock()
	return calls
}

// SetAPIKey calls SetAPIKeyFunc.
func (mock *EmailerMock) SetAPIKey(key string) Emailer {
	if mock.SetAPIKeyFunc == nil {
		panic("moq: EmailerMock.SetAPIKeyFunc is nil but Emailer.SetAPIKey was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockEmailerMockSetAPIKey.Lock()
	mock.calls.SetAPIKey = append(mock.calls.SetAPIKey, callInfo)
	lockEmailerMockSetAPIKey.Unlock()
	return mock.SetAPIKeyFunc(key)
}

// SetAPIKeyCalls gets all the calls that were made to SetAPIKey.
// Check the length with:
//     len(mockedEmailer.SetAPIKeyCalls())
func (mock *EmailerMock) SetAPIKeyCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockEmailerMockSetAPIKey.RLock()
	calls = mock.calls.SetAPIKey
	lockEmailerMockSetAPIKey.RUnlock()
	return calls
}

// SetUrl calls SetUrlFunc.
func (mock *EmailerMock) SetUrl(url string) Emailer {
	if mock.SetUrlFunc == nil {
		panic("moq: EmailerMock.SetUrlFunc is nil but Emailer.SetUrl was just called")
	}
	callInfo := struct {
		URL string
	}{
		URL: url,
	}
	lockEmailerMockSetUrl.Lock()
	mock.calls.SetUrl = append(mock.calls.SetUrl, callInfo)
	lockEmailerMockSetUrl.Unlock()
	return mock.SetUrlFunc(url)
}

// SetUrlCalls gets all the calls that were made to SetUrl.
// Check the length with:
//     len(mockedEmailer.SetUrlCalls())
func (mock *EmailerMock) SetUrlCalls() []struct {
	URL string
} {
	var calls []struct {
		URL string
	}
	lockEmailerMockSetUrl.RLock()
	calls = mock.calls.SetUrl
	lockEmailerMockSetUrl.RUnlock()
	return calls
}

// Subject calls SubjectFunc.
func (mock *EmailerMock) Subject(subject *string) Emailer {
	if mock.SubjectFunc == nil {
		panic("moq: EmailerMock.SubjectFunc is nil but Emailer.Subject was just called")
	}
	callInfo := struct {
		Subject *string
	}{
		Subject: subject,
	}
	lockEmailerMockSubject.Lock()
	mock.calls.Subject = append(mock.calls.Subject, callInfo)
	lockEmailerMockSubject.Unlock()
	return mock.SubjectFunc(subject)
}

// SubjectCalls gets all the calls that were made to Subject.
// Check the length with:
//     len(mockedEmailer.SubjectCalls())
func (mock *EmailerMock) SubjectCalls() []struct {
	Subject *string
} {
	var calls []struct {
		Subject *string
	}
	lockEmailerMockSubject.RLock()
	calls = mock.calls.Subject
	lockEmailerMockSubject.RUnlock()
	return calls
}

// To calls ToFunc.
func (mock *EmailerMock) To(addresses []*api.Address) Emailer {
	if mock.ToFunc == nil {
		panic("moq: EmailerMock.ToFunc is nil but Emailer.To was just called")
	}
	callInfo := struct {
		Addresses []*api.Address
	}{
		Addresses: addresses,
	}
	lockEmailerMockTo.Lock()
	mock.calls.To = append(mock.calls.To, callInfo)
	lockEmailerMockTo.Unlock()
	return mock.ToFunc(addresses)
}

// ToCalls gets all the calls that were made to To.
// Check the length with:
//     len(mockedEmailer.ToCalls())
func (mock *EmailerMock) ToCalls() []struct {
	Addresses []*api.Address
} {
	var calls []struct {
		Addresses []*api.Address
	}
	lockEmailerMockTo.RLock()
	calls = mock.calls.To
	lockEmailerMockTo.RUnlock()
	return calls
}
